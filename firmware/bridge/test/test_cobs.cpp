/**
 * Waggle Bridge — COBS encoder unit tests.
 *
 * These tests run on the host (native platform) and verify that the C++
 * COBS encoder produces output identical to the Python encoder in
 * backend/waggle/utils/cobs.py.
 *
 * Test vectors were generated by running the Python encoder and capturing
 * the exact byte sequences.
 */

#include <unity.h>
#include <string.h>

#include "../src/cobs.h"
#include "../src/config.h"

// ---- Helper: assert encoded output matches expected bytes ----
static void assert_encode(const uint8_t* input, size_t input_len,
                          const uint8_t* expected, size_t expected_len) {
    uint8_t buf[256];
    size_t n = cobs_encode(input, input_len, buf);
    TEST_ASSERT_EQUAL_UINT(expected_len, n);
    TEST_ASSERT_EQUAL_UINT8_ARRAY(expected, buf, expected_len);
}

// ---- Helper: verify no zero bytes in encoded output ----
static void assert_no_zeros(const uint8_t* buf, size_t len) {
    for (size_t i = 0; i < len; i++) {
        TEST_ASSERT_NOT_EQUAL_MESSAGE(0x00, buf[i],
            "Encoded output must not contain 0x00");
    }
}

// -------- Test cases --------

/**
 * Empty input encodes to [0x01].
 * Python: cobs_encode(b'') == b'\x01'
 */
void test_cobs_encode_empty(void) {
    const uint8_t expected[] = {0x01};
    assert_encode(NULL, 0, expected, sizeof(expected));
}

/**
 * Single zero byte encodes to [0x01, 0x01].
 * Python: cobs_encode(b'\x00') == b'\x01\x01'
 */
void test_cobs_encode_single_zero(void) {
    const uint8_t input[]    = {0x00};
    const uint8_t expected[] = {0x01, 0x01};
    assert_encode(input, sizeof(input), expected, sizeof(expected));
}

/**
 * No zeros: [0x01, 0x02, 0x03] encodes to [0x04, 0x01, 0x02, 0x03].
 * Python: cobs_encode(b'\x01\x02\x03') == b'\x04\x01\x02\x03'
 */
void test_cobs_encode_no_zeros(void) {
    const uint8_t input[]    = {0x01, 0x02, 0x03};
    const uint8_t expected[] = {0x04, 0x01, 0x02, 0x03};
    assert_encode(input, sizeof(input), expected, sizeof(expected));
}

/**
 * All zeros: [0x00, 0x00, 0x00] encodes to [0x01, 0x01, 0x01, 0x01].
 * Python: cobs_encode(b'\x00\x00\x00') == b'\x01\x01\x01\x01'
 */
void test_cobs_encode_all_zeros(void) {
    const uint8_t input[]    = {0x00, 0x00, 0x00};
    const uint8_t expected[] = {0x01, 0x01, 0x01, 0x01};
    assert_encode(input, sizeof(input), expected, sizeof(expected));
}

/**
 * Mixed data: [0x01, 0x00, 0x02, 0x03, 0x00, 0x04]
 * encodes to [0x02, 0x01, 0x03, 0x02, 0x03, 0x02, 0x04].
 * Python: cobs_encode(b'\x01\x00\x02\x03\x00\x04')
 *         == b'\x02\x01\x03\x02\x03\x02\x04'
 */
void test_cobs_encode_mixed(void) {
    const uint8_t input[]    = {0x01, 0x00, 0x02, 0x03, 0x00, 0x04};
    const uint8_t expected[] = {0x02, 0x01, 0x03, 0x02, 0x03, 0x02, 0x04};
    assert_encode(input, sizeof(input), expected, sizeof(expected));
}

/**
 * Typical 38-byte frame: bytes(range(38)) — starts with 0x00.
 * Python: len(cobs_encode(bytes(range(38)))) == 39
 *
 * Expected output verified from Python:
 * [0x01, 0x26, 0x01, 0x02, ..., 0x25]
 * (first byte 0x01 = code for the leading zero, then 0x26 = code for
 * the remaining 37 non-zero bytes 0x01..0x25)
 */
void test_cobs_encode_38byte_frame(void) {
    uint8_t input[38];
    for (int i = 0; i < 38; i++) {
        input[i] = (uint8_t)i;  // 0x00, 0x01, ..., 0x25
    }

    // Expected from Python: [0x01, 0x26, 0x01, 0x02, ..., 0x25]
    uint8_t expected[39];
    expected[0] = 0x01;  // Code for the leading zero byte
    expected[1] = 0x26;  // Code: 37 non-zero bytes + 1 = 38 = 0x26
    for (int i = 1; i <= 37; i++) {
        expected[i + 1] = (uint8_t)i;  // 0x01 through 0x25
    }

    assert_encode(input, sizeof(input), expected, sizeof(expected));
}

/**
 * 38-byte frame with no zeros: bytes([1..38]).
 * Python: cobs_encode(bytes(range(1,39))) produces [0x27, 0x01, ..., 0x26]
 * (single block, code = 38+1 = 0x27).
 */
void test_cobs_encode_38byte_no_zeros(void) {
    uint8_t input[38];
    for (int i = 0; i < 38; i++) {
        input[i] = (uint8_t)(i + 1);  // 0x01 through 0x26
    }

    uint8_t expected[39];
    expected[0] = 0x27;  // Code: 38 non-zero bytes + 1 = 39 = 0x27
    for (int i = 0; i < 38; i++) {
        expected[i + 1] = (uint8_t)(i + 1);
    }

    assert_encode(input, sizeof(input), expected, sizeof(expected));
}

/**
 * Verify encoded output never contains 0x00 for various inputs.
 */
void test_cobs_encode_no_internal_zeros(void) {
    uint8_t buf[256];
    size_t n;

    // Empty
    n = cobs_encode(NULL, 0, buf);
    assert_no_zeros(buf, n);

    // Single zero
    {
        const uint8_t d[] = {0x00};
        n = cobs_encode(d, sizeof(d), buf);
        assert_no_zeros(buf, n);
    }

    // All zeros
    {
        const uint8_t d[] = {0x00, 0x00, 0x00, 0x00, 0x00};
        n = cobs_encode(d, sizeof(d), buf);
        assert_no_zeros(buf, n);
    }

    // Mixed
    {
        const uint8_t d[] = {0x01, 0x00, 0x02, 0x03, 0x00, 0x04};
        n = cobs_encode(d, sizeof(d), buf);
        assert_no_zeros(buf, n);
    }

    // 38-byte frame with zeros
    {
        uint8_t d[38];
        for (int i = 0; i < 38; i++) d[i] = (uint8_t)i;
        n = cobs_encode(d, sizeof(d), buf);
        assert_no_zeros(buf, n);
    }
}

/**
 * Test 254 non-zero bytes — max block before code overflow.
 * Code should be 0xFF (254+1=255) with no trailing implicit zero.
 * Python: cobs_encode(bytes(range(1,255))) has length 255.
 */
void test_cobs_encode_254_nonzero(void) {
    uint8_t input[254];
    for (int i = 0; i < 254; i++) {
        input[i] = (uint8_t)(i + 1);  // 0x01..0xFE
    }

    uint8_t buf[260];
    size_t n = cobs_encode(input, 254, buf);

    // Should be: [0xFF, 0x01, 0x02, ..., 0xFE] = 255 bytes
    TEST_ASSERT_EQUAL_UINT(255, n);
    TEST_ASSERT_EQUAL_UINT8(0xFF, buf[0]);
    for (int i = 0; i < 254; i++) {
        TEST_ASSERT_EQUAL_UINT8((uint8_t)(i + 1), buf[i + 1]);
    }
    assert_no_zeros(buf, n);
}

/**
 * Test 255 non-zero bytes — forces a block split.
 * First block: 0xFF + 254 data bytes. Second block: code + 1 data byte.
 */
void test_cobs_encode_255_nonzero(void) {
    uint8_t input[255];
    for (int i = 0; i < 255; i++) {
        input[i] = (uint8_t)((i % 254) + 1);  // Non-zero values
    }

    uint8_t buf[260];
    size_t n = cobs_encode(input, 255, buf);

    // First block: 0xFF + 254 bytes = 255. Second block: code(0x02) + 1 byte = 2.
    // Total = 257 bytes.
    TEST_ASSERT_EQUAL_UINT(257, n);
    TEST_ASSERT_EQUAL_UINT8(0xFF, buf[0]);
    TEST_ASSERT_EQUAL_UINT8(0x02, buf[255]);  // Code for 1 non-zero byte
    assert_no_zeros(buf, n);
}

/**
 * Trailing zero byte: [0x01, 0x02, 0x00].
 * Encoded: [0x03, 0x01, 0x02, 0x01].
 * The trailing zero produces a final code byte of 0x01.
 */
void test_cobs_encode_trailing_zero(void) {
    const uint8_t input[]    = {0x01, 0x02, 0x00};
    const uint8_t expected[] = {0x03, 0x01, 0x02, 0x01};
    assert_encode(input, sizeof(input), expected, sizeof(expected));
}

// ---- Unity test runner ----

void setUp(void) {}
void tearDown(void) {}

int main(int argc, char** argv) {
    UNITY_BEGIN();

    RUN_TEST(test_cobs_encode_empty);
    RUN_TEST(test_cobs_encode_single_zero);
    RUN_TEST(test_cobs_encode_no_zeros);
    RUN_TEST(test_cobs_encode_all_zeros);
    RUN_TEST(test_cobs_encode_mixed);
    RUN_TEST(test_cobs_encode_38byte_frame);
    RUN_TEST(test_cobs_encode_38byte_no_zeros);
    RUN_TEST(test_cobs_encode_no_internal_zeros);
    RUN_TEST(test_cobs_encode_254_nonzero);
    RUN_TEST(test_cobs_encode_255_nonzero);
    RUN_TEST(test_cobs_encode_trailing_zero);

    return UNITY_END();
}
