/**
 * Waggle Bridge — COBS encoder unit tests.
 *
 * These tests run on the host (native platform) and verify that the C++
 * COBS encoder produces output identical to the Python encoder in
 * backend/waggle/utils/cobs.py.
 *
 * Test vectors were generated by running the Python encoder and capturing
 * the exact byte sequences.
 */

#include <unity.h>
#include <string.h>

#include "../src/cobs.h"
#include "../src/config.h"

// ---- Helper: assert encoded output matches expected bytes ----
static void assert_encode(const uint8_t* input, size_t input_len,
                          const uint8_t* expected, size_t expected_len) {
    uint8_t buf[256];
    size_t n = cobs_encode(input, input_len, buf);
    TEST_ASSERT_EQUAL_UINT(expected_len, n);
    TEST_ASSERT_EQUAL_UINT8_ARRAY(expected, buf, expected_len);
}

// ---- Helper: verify no zero bytes in encoded output ----
static void assert_no_zeros(const uint8_t* buf, size_t len) {
    for (size_t i = 0; i < len; i++) {
        TEST_ASSERT_NOT_EQUAL_MESSAGE(0x00, buf[i],
            "Encoded output must not contain 0x00");
    }
}

// -------- Test cases --------

/**
 * Empty input encodes to [0x01].
 * Python: cobs_encode(b'') == b'\x01'
 */
void test_cobs_encode_empty(void) {
    const uint8_t expected[] = {0x01};
    assert_encode(NULL, 0, expected, sizeof(expected));
}

/**
 * Single zero byte encodes to [0x01, 0x01].
 * Python: cobs_encode(b'\x00') == b'\x01\x01'
 */
void test_cobs_encode_single_zero(void) {
    const uint8_t input[]    = {0x00};
    const uint8_t expected[] = {0x01, 0x01};
    assert_encode(input, sizeof(input), expected, sizeof(expected));
}

/**
 * No zeros: [0x01, 0x02, 0x03] encodes to [0x04, 0x01, 0x02, 0x03].
 * Python: cobs_encode(b'\x01\x02\x03') == b'\x04\x01\x02\x03'
 */
void test_cobs_encode_no_zeros(void) {
    const uint8_t input[]    = {0x01, 0x02, 0x03};
    const uint8_t expected[] = {0x04, 0x01, 0x02, 0x03};
    assert_encode(input, sizeof(input), expected, sizeof(expected));
}

/**
 * All zeros: [0x00, 0x00, 0x00] encodes to [0x01, 0x01, 0x01, 0x01].
 * Python: cobs_encode(b'\x00\x00\x00') == b'\x01\x01\x01\x01'
 */
void test_cobs_encode_all_zeros(void) {
    const uint8_t input[]    = {0x00, 0x00, 0x00};
    const uint8_t expected[] = {0x01, 0x01, 0x01, 0x01};
    assert_encode(input, sizeof(input), expected, sizeof(expected));
}

/**
 * Mixed data: [0x01, 0x00, 0x02, 0x03, 0x00, 0x04]
 * encodes to [0x02, 0x01, 0x03, 0x02, 0x03, 0x02, 0x04].
 * Python: cobs_encode(b'\x01\x00\x02\x03\x00\x04')
 *         == b'\x02\x01\x03\x02\x03\x02\x04'
 */
void test_cobs_encode_mixed(void) {
    const uint8_t input[]    = {0x01, 0x00, 0x02, 0x03, 0x00, 0x04};
    const uint8_t expected[] = {0x02, 0x01, 0x03, 0x02, 0x03, 0x02, 0x04};
    assert_encode(input, sizeof(input), expected, sizeof(expected));
}

/**
 * Typical 38-byte frame: bytes(range(38)) — starts with 0x00.
 * Python: len(cobs_encode(bytes(range(38)))) == 39
 *
 * Expected output verified from Python:
 * [0x01, 0x26, 0x01, 0x02, ..., 0x25]
 * (first byte 0x01 = code for the leading zero, then 0x26 = code for
 * the remaining 37 non-zero bytes 0x01..0x25)
 */
void test_cobs_encode_38byte_frame(void) {
    uint8_t input[38];
    for (int i = 0; i < 38; i++) {
        input[i] = (uint8_t)i;  // 0x00, 0x01, ..., 0x25
    }

    // Expected from Python: [0x01, 0x26, 0x01, 0x02, ..., 0x25]
    uint8_t expected[39];
    expected[0] = 0x01;  // Code for the leading zero byte
    expected[1] = 0x26;  // Code: 37 non-zero bytes + 1 = 38 = 0x26
    for (int i = 1; i <= 37; i++) {
        expected[i + 1] = (uint8_t)i;  // 0x01 through 0x25
    }

    assert_encode(input, sizeof(input), expected, sizeof(expected));
}

/**
 * 38-byte frame with no zeros: bytes([1..38]).
 * Python: cobs_encode(bytes(range(1,39))) produces [0x27, 0x01, ..., 0x26]
 * (single block, code = 38+1 = 0x27).
 */
void test_cobs_encode_38byte_no_zeros(void) {
    uint8_t input[38];
    for (int i = 0; i < 38; i++) {
        input[i] = (uint8_t)(i + 1);  // 0x01 through 0x26
    }

    uint8_t expected[39];
    expected[0] = 0x27;  // Code: 38 non-zero bytes + 1 = 39 = 0x27
    for (int i = 0; i < 38; i++) {
        expected[i + 1] = (uint8_t)(i + 1);
    }

    assert_encode(input, sizeof(input), expected, sizeof(expected));
}

/**
 * Verify encoded output never contains 0x00 for various inputs.
 */
void test_cobs_encode_no_internal_zeros(void) {
    uint8_t buf[256];
    size_t n;

    // Empty
    n = cobs_encode(NULL, 0, buf);
    assert_no_zeros(buf, n);

    // Single zero
    {
        const uint8_t d[] = {0x00};
        n = cobs_encode(d, sizeof(d), buf);
        assert_no_zeros(buf, n);
    }

    // All zeros
    {
        const uint8_t d[] = {0x00, 0x00, 0x00, 0x00, 0x00};
        n = cobs_encode(d, sizeof(d), buf);
        assert_no_zeros(buf, n);
    }

    // Mixed
    {
        const uint8_t d[] = {0x01, 0x00, 0x02, 0x03, 0x00, 0x04};
        n = cobs_encode(d, sizeof(d), buf);
        assert_no_zeros(buf, n);
    }

    // 38-byte frame with zeros
    {
        uint8_t d[38];
        for (int i = 0; i < 38; i++) d[i] = (uint8_t)i;
        n = cobs_encode(d, sizeof(d), buf);
        assert_no_zeros(buf, n);
    }
}

/**
 * Test 254 non-zero bytes — max block before code overflow.
 * Code should be 0xFF (254+1=255) with no trailing implicit zero.
 * Python: cobs_encode(bytes(range(1,255))) has length 255.
 */
void test_cobs_encode_254_nonzero(void) {
    uint8_t input[254];
    for (int i = 0; i < 254; i++) {
        input[i] = (uint8_t)(i + 1);  // 0x01..0xFE
    }

    uint8_t buf[260];
    size_t n = cobs_encode(input, 254, buf);

    // Should be: [0xFF, 0x01, 0x02, ..., 0xFE] = 255 bytes
    TEST_ASSERT_EQUAL_UINT(255, n);
    TEST_ASSERT_EQUAL_UINT8(0xFF, buf[0]);
    for (int i = 0; i < 254; i++) {
        TEST_ASSERT_EQUAL_UINT8((uint8_t)(i + 1), buf[i + 1]);
    }
    assert_no_zeros(buf, n);
}

/**
 * Test 255 non-zero bytes — forces a block split.
 * First block: 0xFF + 254 data bytes. Second block: code + 1 data byte.
 */
void test_cobs_encode_255_nonzero(void) {
    uint8_t input[255];
    for (int i = 0; i < 255; i++) {
        input[i] = (uint8_t)((i % 254) + 1);  // Non-zero values
    }

    uint8_t buf[260];
    size_t n = cobs_encode(input, 255, buf);

    // First block: 0xFF + 254 bytes = 255. Second block: code(0x02) + 1 byte = 2.
    // Total = 257 bytes.
    TEST_ASSERT_EQUAL_UINT(257, n);
    TEST_ASSERT_EQUAL_UINT8(0xFF, buf[0]);
    TEST_ASSERT_EQUAL_UINT8(0x02, buf[255]);  // Code for 1 non-zero byte
    assert_no_zeros(buf, n);
}

/**
 * Trailing zero byte: [0x01, 0x02, 0x00].
 * Encoded: [0x03, 0x01, 0x02, 0x01].
 * The trailing zero produces a final code byte of 0x01.
 */
void test_cobs_encode_trailing_zero(void) {
    const uint8_t input[]    = {0x01, 0x02, 0x00};
    const uint8_t expected[] = {0x03, 0x01, 0x02, 0x01};
    assert_encode(input, sizeof(input), expected, sizeof(expected));
}

// ---- Phase 2: 54-byte frame tests ----

/**
 * 54-byte frame (Phase 2): bytes(range(54)) — starts with 0x00.
 * Python: len(cobs_encode(bytes(range(54)))) == 55
 *
 * Expected output verified from Python:
 * [0x01, 0x36, 0x01, 0x02, ..., 0x35]
 * (first byte 0x01 = code for the leading zero, then 0x36 = code for
 * the remaining 53 non-zero bytes 0x01..0x35)
 */
void test_cobs_encode_54byte_frame(void) {
    uint8_t input[54];
    for (int i = 0; i < 54; i++) {
        input[i] = (uint8_t)i;  // 0x00, 0x01, ..., 0x35
    }

    // Expected from Python: [0x01, 0x36, 0x01, 0x02, ..., 0x35]
    uint8_t expected[55];
    expected[0] = 0x01;  // Code for the leading zero byte
    expected[1] = 0x36;  // Code: 53 non-zero bytes + 1 = 54 = 0x36
    for (int i = 1; i <= 53; i++) {
        expected[i + 1] = (uint8_t)i;  // 0x01 through 0x35
    }

    assert_encode(input, sizeof(input), expected, sizeof(expected));
}

/**
 * 54-byte frame with no zeros: bytes([1..54]).
 * Python: cobs_encode(bytes(range(1,55))) produces [0x37, 0x01, ..., 0x36]
 * (single block, code = 54+1 = 0x37).
 */
void test_cobs_encode_54byte_no_zeros(void) {
    uint8_t input[54];
    for (int i = 0; i < 54; i++) {
        input[i] = (uint8_t)(i + 1);  // 0x01 through 0x36
    }

    uint8_t expected[55];
    expected[0] = 0x37;  // Code: 54 non-zero bytes + 1 = 55 = 0x37
    for (int i = 0; i < 54; i++) {
        expected[i + 1] = (uint8_t)(i + 1);
    }

    assert_encode(input, sizeof(input), expected, sizeof(expected));
}

/**
 * COBS encode/decode roundtrip for 54-byte frame.
 *
 * Since the bridge only encodes (decode is on the Python side), we verify
 * the roundtrip property manually: encode, then decode by hand, and check
 * the result matches the original input.
 *
 * COBS decode algorithm:
 *   1. Read code byte.
 *   2. Copy (code - 1) data bytes.
 *   3. If code != 0xFF, emit a zero (unless at end of data).
 *   4. Repeat until all encoded bytes consumed.
 */
static size_t cobs_decode_test(const uint8_t* encoded, size_t enc_len,
                                uint8_t* decoded, size_t dec_max) {
    size_t di = 0;  // decoded index
    size_t ei = 0;  // encoded index

    while (ei < enc_len) {
        uint8_t code = encoded[ei++];
        if (code == 0) break;  // Unexpected zero — malformed

        for (uint8_t j = 1; j < code; j++) {
            if (ei >= enc_len || di >= dec_max) return 0;  // Error
            decoded[di++] = encoded[ei++];
        }

        // Append implicit zero unless code is 0xFF or we're at end
        if (code != 0xFF && ei < enc_len) {
            if (di >= dec_max) return 0;
            decoded[di++] = 0x00;
        }
    }

    return di;
}

/**
 * Roundtrip test for 54-byte frame (Phase 2 bee-counting payload size).
 * Encode then decode should produce the exact original data.
 */
void test_cobs_roundtrip_54byte(void) {
    // Build a realistic 54-byte frame: 6-byte MAC + 48-byte payload
    uint8_t original[54];
    for (int i = 0; i < 54; i++) {
        original[i] = (uint8_t)((i * 7 + 13) & 0xFF);  // Pseudo-random pattern
    }

    // Encode
    uint8_t encoded[COBS_MAX_OUTPUT];
    size_t enc_len = cobs_encode(original, 54, encoded);

    // Verify no zeros in encoded output
    assert_no_zeros(encoded, enc_len);

    // Decode
    uint8_t decoded[64];
    size_t dec_len = cobs_decode_test(encoded, enc_len, decoded, sizeof(decoded));

    // Verify roundtrip
    TEST_ASSERT_EQUAL_UINT(54, dec_len);
    TEST_ASSERT_EQUAL_UINT8_ARRAY(original, decoded, 54);
}

/**
 * Roundtrip test for 38-byte frame (Phase 1 regression).
 * Encode then decode should produce the exact original data.
 */
void test_cobs_roundtrip_38byte(void) {
    // Build a 38-byte frame: 6-byte MAC + 32-byte payload
    uint8_t original[38];
    for (int i = 0; i < 38; i++) {
        original[i] = (uint8_t)((i * 11 + 3) & 0xFF);  // Pseudo-random pattern
    }

    // Encode
    uint8_t encoded[COBS_MAX_OUTPUT];
    size_t enc_len = cobs_encode(original, 38, encoded);

    // Verify no zeros in encoded output
    assert_no_zeros(encoded, enc_len);

    // Decode
    uint8_t decoded[64];
    size_t dec_len = cobs_decode_test(encoded, enc_len, decoded, sizeof(decoded));

    // Verify roundtrip
    TEST_ASSERT_EQUAL_UINT(38, dec_len);
    TEST_ASSERT_EQUAL_UINT8_ARRAY(original, decoded, 38);
}

/**
 * Verify encoded output never contains 0x00 for 54-byte frames.
 */
void test_cobs_encode_54byte_no_internal_zeros(void) {
    uint8_t buf[COBS_MAX_OUTPUT];
    size_t n;

    // 54-byte frame with zeros
    {
        uint8_t d[54];
        for (int i = 0; i < 54; i++) d[i] = (uint8_t)i;
        n = cobs_encode(d, sizeof(d), buf);
        assert_no_zeros(buf, n);
    }

    // 54-byte frame with no zeros
    {
        uint8_t d[54];
        for (int i = 0; i < 54; i++) d[i] = (uint8_t)(i + 1);
        n = cobs_encode(d, sizeof(d), buf);
        assert_no_zeros(buf, n);
    }

    // 54-byte frame all zeros
    {
        uint8_t d[54];
        memset(d, 0, sizeof(d));
        n = cobs_encode(d, sizeof(d), buf);
        assert_no_zeros(buf, n);
    }
}

/**
 * Both 38-byte and 54-byte decoded sizes are valid frame sizes.
 * This test ensures the COBS encoding handles both Phase 1 and Phase 2
 * frame sizes correctly and produces correctly sized outputs.
 */
void test_cobs_both_frame_sizes_valid(void) {
    uint8_t buf[COBS_MAX_OUTPUT];

    // 38-byte frame (Phase 1): 6-byte MAC + 32-byte payload
    {
        uint8_t frame[FRAME_LEN_P1];
        memset(frame, 0xAA, sizeof(frame));
        size_t n = cobs_encode(frame, FRAME_LEN_P1, buf);

        // For 38 bytes of non-zero data: encoded = 39 bytes (code + 38 data)
        TEST_ASSERT_EQUAL_UINT(39, n);
        assert_no_zeros(buf, n);
        TEST_ASSERT_TRUE_MESSAGE(n <= COBS_MAX_OUTPUT,
            "38-byte frame encoding exceeds COBS_MAX_OUTPUT");
    }

    // 54-byte frame (Phase 2): 6-byte MAC + 48-byte payload
    {
        uint8_t frame[FRAME_LEN_P2];
        memset(frame, 0xBB, sizeof(frame));
        size_t n = cobs_encode(frame, FRAME_LEN_P2, buf);

        // For 54 bytes of non-zero data: encoded = 55 bytes (code + 54 data)
        TEST_ASSERT_EQUAL_UINT(55, n);
        assert_no_zeros(buf, n);
        TEST_ASSERT_TRUE_MESSAGE(n <= COBS_MAX_OUTPUT,
            "54-byte frame encoding exceeds COBS_MAX_OUTPUT");
    }
}

// ---- Unity test runner ----

void setUp(void) {}
void tearDown(void) {}

int main(int argc, char** argv) {
    UNITY_BEGIN();

    // Phase 1 tests (regression)
    RUN_TEST(test_cobs_encode_empty);
    RUN_TEST(test_cobs_encode_single_zero);
    RUN_TEST(test_cobs_encode_no_zeros);
    RUN_TEST(test_cobs_encode_all_zeros);
    RUN_TEST(test_cobs_encode_mixed);
    RUN_TEST(test_cobs_encode_38byte_frame);
    RUN_TEST(test_cobs_encode_38byte_no_zeros);
    RUN_TEST(test_cobs_encode_no_internal_zeros);
    RUN_TEST(test_cobs_encode_254_nonzero);
    RUN_TEST(test_cobs_encode_255_nonzero);
    RUN_TEST(test_cobs_encode_trailing_zero);

    // Phase 2 tests (54-byte frames)
    RUN_TEST(test_cobs_encode_54byte_frame);
    RUN_TEST(test_cobs_encode_54byte_no_zeros);
    RUN_TEST(test_cobs_roundtrip_54byte);
    RUN_TEST(test_cobs_roundtrip_38byte);
    RUN_TEST(test_cobs_encode_54byte_no_internal_zeros);
    RUN_TEST(test_cobs_both_frame_sizes_valid);

    return UNITY_END();
}
